/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ScrambleTextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  cssclass: "",
  fps: 30,
  duration: 600,
  regular_shuffle: true,
  keyboard_shuffle: true,
  rolling_shuffle: true,
  overshoot_shuffle: true,
  regular_finish: true,
  error_finish: true
};
var ScrambleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("CSS class name").setDesc("Leave blank for effect to apply to every note. If you only want the effect on certain notes, change this to the name of the tag you will put in the `cssclasses` frontmatter field of target notes").addText(
      (text) => text.setValue(this.plugin.settings.cssclass).onChange(async (value) => {
        this.plugin.settings.cssclass = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("FPS").setDesc("Frames per second of the animation").addText((text) => {
      text.setPlaceholder("30").setValue(String(this.plugin.settings.fps)).onChange(async (value) => {
        this.plugin.settings.fps = Number(value);
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "number";
      text.inputEl.min = "1";
      text.inputEl.max = "120";
    });
    new import_obsidian.Setting(containerEl).setName("Animation duration (ms)").setDesc("How long the scrambling animation will be, in miliseconds. The unscrambling time is independent of this").addText((text) => {
      text.setPlaceholder("600").setValue(String(this.plugin.settings.duration)).onChange(async (value) => {
        this.plugin.settings.duration = Number(value);
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "number";
      text.inputEl.min = "200";
      text.inputEl.max = "9999";
    });
    new import_obsidian.Setting(containerEl).setName("Reset settings").setDesc("Change all the settings back to default").addButton((button) => {
      button.setButtonText("Reset");
      button.onClick(async () => {
        this.plugin.settings = Object.assign({}, this.plugin.settings, DEFAULT_SETTINGS);
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Scrambling variants").setHeading();
    containerEl.createEl("p", { text: "There are multiple different scrambling animations. Pick which ones you'd like to see. One of the enabled ones is picked randomly when you open a note to animate the scrambling process. If nothing is picked, the regular options are used" });
    new import_obsidian.Setting(containerEl).setName("Regular shuffle").setDesc("The entire title is scrambled").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.regular_shuffle).onChange(async (value) => {
          this.plugin.settings.regular_shuffle = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Keyboard smash shuffle").setDesc("The scrambled title increases by one character every frame. Looks like somebody smashing their keyboard").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.keyboard_shuffle).onChange(async (value) => {
          this.plugin.settings.keyboard_shuffle = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Rolling shuffle").setDesc("The title is typed out letter by letter, with older characters being unscrambled. Does not play a finishing animation because it finishes the text by itself. Additionally, doesn't change based on fps or duration settings").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.rolling_shuffle).onChange(async (value) => {
          this.plugin.settings.rolling_shuffle = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Overshooting shuffle").setDesc("Using an easing function, the scrambled text overshoots the character limit of the title, then bounces back").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.overshoot_shuffle).onChange(async (value) => {
          this.plugin.settings.overshoot_shuffle = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Unscrambling variants").setHeading();
    containerEl.createEl("p", { text: "After some time, there is a separate animation to unveil the scrambled text" });
    new import_obsidian.Setting(containerEl).setName("Regular finish").setDesc("The title is unveilded letter by letter").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.regular_finish).onChange(async (value) => {
          this.plugin.settings.regular_finish = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Finish with errors").setDesc("Same as regular finish, but it leaves errors the first time, then does a second pass to correct them").addToggle(
      (toggle) => {
        toggle.setValue(this.plugin.settings.error_finish).onChange(async (value) => {
          this.plugin.settings.error_finish = value;
          await this.plugin.saveSettings();
          this.display();
        });
      }
    );
  }
};

// src/shuffling.ts
var import_promises = require("timers/promises");
function get_char(custom_set = "") {
  const lower = "abcdefghijklmnopqrstuvwxyz";
  const upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const num = "0123456789";
  const symbols = "?/\\(^)![]{}&^%$#";
  let chars = (lower + upper + num + symbols).split("");
  if (custom_set != "") {
    chars = custom_set.split("");
  }
  const randomElement = chars[Math.floor(Math.random() * chars.length)];
  return randomElement;
}
function get_garbled_string(length) {
  let answer = "";
  for (const _ of "W".repeat(length)) {
    answer += get_char();
  }
  return answer;
}
async function pick_finish(settings, titleEl, og_title, view, delta) {
  const available_function = [];
  if (settings.error_finish == true) {
    available_function.push(finish_with_errors);
  }
  if (settings.regular_finish == true || available_function.length == 0) {
    available_function.push(finish);
  }
  const picked_function = available_function[Math.floor(Math.random() * available_function.length)];
  await picked_function(titleEl, og_title, view, delta);
}
async function finish(titleEl, og_title, view, delta) {
  var _a, _b, _c;
  console.debug("REGULAR FINISH");
  const current_text = (_a = titleEl.textContent) == null ? void 0 : _a.split("");
  for (let frame = 0; frame < og_title.length; frame++) {
    if (og_title != ((_b = view.file) == null ? void 0 : _b.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    current_text[frame] = og_title.split("")[frame];
    titleEl.setText(current_text.join(""));
    await (0, import_promises.setTimeout)(delta);
  }
  if (current_text.length > og_title.length) {
    for (let frame = og_title.length; frame < current_text.length; frame++) {
      if (og_title != ((_c = view.file) == null ? void 0 : _c.basename)) {
        console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
        return;
      }
      current_text[frame] = "";
      titleEl.setText(current_text.join(""));
      await (0, import_promises.setTimeout)(delta);
    }
  }
  titleEl.setText(og_title);
  titleEl.classList.remove("compliance-class");
}
async function finish_with_errors(titleEl, og_title, view, delta) {
  var _a, _b;
  console.debug("FINISH WITH ERRORS");
  const current_text = (_a = titleEl.textContent) == null ? void 0 : _a.split("");
  for (let frame = 0; frame < og_title.length; frame++) {
    if (og_title != ((_b = view.file) == null ? void 0 : _b.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    const chance = Math.random();
    if (chance < 0.2) {
      current_text[frame] = get_char("?/\\()![]{}&%$#");
    } else {
      current_text[frame] = og_title.split("")[frame];
    }
    titleEl.setText(current_text.join(""));
    await (0, import_promises.setTimeout)(delta);
  }
  finish(titleEl, og_title, view, delta);
}
async function shuffle(view, og_title, settings) {
  var _a;
  console.debug("REGULAR SHUFFLE");
  const titleEl = view.inlineTitleEl;
  const delta = 1e3 / settings.fps;
  const n_frames = settings.duration / delta;
  titleEl.classList.add("compliance-class");
  for (let frame = 0; frame < n_frames; frame++) {
    if (og_title != ((_a = view.file) == null ? void 0 : _a.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    titleEl.setText(get_garbled_string(og_title.length));
    await (0, import_promises.setTimeout)(delta);
  }
  pick_finish(settings, titleEl, og_title, view, delta);
}
async function shuffle_keysmash(view, og_title, settings) {
  var _a;
  console.debug("KEYSMASH SHUFFLE");
  const titleEl = view.inlineTitleEl;
  const delta = 1e3 / settings.fps;
  const n_frames = settings.duration / delta;
  titleEl.classList.add("compliance-class");
  for (let frame = 0; frame < n_frames; frame++) {
    if (og_title != ((_a = view.file) == null ? void 0 : _a.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    titleEl.setText(get_garbled_string(frame));
    await (0, import_promises.setTimeout)(delta);
  }
  pick_finish(settings, titleEl, og_title, view, delta);
}
async function rolling_shuffle(view, og_title, settings) {
  var _a;
  console.debug("ROLLING SHUFFLE");
  const titleEl = view.inlineTitleEl;
  let n_frames = og_title.length;
  const scramble_buffer = 7;
  n_frames += scramble_buffer;
  const delta = 1e3 / n_frames;
  titleEl.classList.add("compliance-class");
  for (let frame = 0; frame < n_frames; frame++) {
    if (og_title != ((_a = view.file) == null ? void 0 : _a.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    if (frame >= scramble_buffer + 1) {
      const scrambled = get_garbled_string(Math.min(frame, scramble_buffer, n_frames - frame - 1));
      const fixed = og_title.split("").slice(0, frame - scramble_buffer + 1);
      const output = fixed.concat(scrambled.slice(scramble_buffer - frame, scrambled.length));
      titleEl.setText(output.join(""));
    } else {
      titleEl.setText(get_garbled_string(frame));
    }
    await (0, import_promises.setTimeout)(delta);
  }
}
async function shuffle_with_easing(view, og_title, settings, easing_function) {
  var _a;
  console.debug("SHUFFLE WITH EASING");
  const titleEl = view.inlineTitleEl;
  const delta = 1e3 / settings.fps;
  const n_frames = settings.duration / delta;
  titleEl.classList.add("compliance-class");
  for (let frame = 0; frame < n_frames; frame++) {
    if (og_title != ((_a = view.file) == null ? void 0 : _a.basename)) {
      console.debug("THIS AIN'T THE SAME FILE ANYMORE, ABORT");
      return;
    }
    const easing_coefficient = easing_function((frame + 1) / n_frames);
    const garble_length = easing_coefficient * og_title.length;
    titleEl.setText(get_garbled_string(garble_length));
    await (0, import_promises.setTimeout)(delta);
  }
  pick_finish(settings, titleEl, og_title, view, delta);
}

// src/easing.ts
function easeOutBack(x) {
  const c1 = 4.9;
  const c3 = c1 + 1;
  return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
}

// src/main.ts
async function pick_shuffle(view, og_title, settings, easing_function) {
  const available_functions = [];
  if (settings.keyboard_shuffle == true) {
    available_functions.push(shuffle_keysmash);
  }
  if (settings.rolling_shuffle == true) {
    if (og_title.length > 7) {
      available_functions.push(rolling_shuffle);
    }
  }
  if (settings.overshoot_shuffle == true) {
    available_functions.push(shuffle_with_easing);
  }
  if (settings.regular_shuffle == true || available_functions.length == 0) {
    available_functions.push(shuffle);
  }
  const picked_function = available_functions[Math.floor(Math.random() * available_functions.length)];
  await picked_function(view, og_title, settings, easing_function);
}
var ScrambleTextPlugin = class extends import_obsidian2.Plugin {
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ScrambleSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      console.debug("BIG LEAF MOMENT (new note, scrambling)");
      const view = leaf.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (view == null) {
        return;
      }
      if (this.settings.cssclass == "") {
        pick_shuffle(view, view.inlineTitleEl.textContent, this.settings, easeOutBack);
        return;
      }
      const cssclass = this.settings.cssclass;
      const file = this.app.workspace.getActiveFile();
      if (file) {
        this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          if (frontmatter.cssclasses && frontmatter.cssclasses.includes(cssclass)) {
            console.debug("cssclass found: " + cssclass);
            pick_shuffle(view, view.inlineTitleEl.textContent, this.settings, easeOutBack);
            return;
          }
        });
      }
    }));
  }
  onunload() {
  }
};


/* nosourcemap */